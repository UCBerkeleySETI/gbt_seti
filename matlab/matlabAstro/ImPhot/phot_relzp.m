function Out=phot_relzp(Mag,Err,varargin)
%--------------------------------------------------------------------------
% phot_relzp function                                               ImPhot
% Description: Given a matrix of instrumental magnitudes (and possibly
%              errors) for aech epoch (image) and each source find the
%              best fit zero point per epoch and mean magnitude per star
%              that will minimize the residuals of the sources over all
%              epochs. In its most basic form, this function solve the
%              equation: InstMag_ij = ZP_i + <Mag>_j, where ZP_i is the
%              zero-point of the i-th image, and <Mag>_j is the mean
%              magnitude of the j-th star.
%              UNDER DEVELOPMEMT - MAY CHANGE.
% Input  : - A matrix of instrumental magnitudes of the forms
%            (ImageIndex,SourceIndex).
%            Alternatively, this can be a structure array in which the
%            'Mag' field contains this matrix, and the 'Err' field
%            contains the corresponding matrix of instrumental mag errors.
%            If empty will run in simulation mode.
%            This structure can be generated by simcat_matchcoo.m.
%          - A matrix of instrumental magnitudes errors of the forms
%            (ImageIndex,SourceIndex).
%            If empty, will use the 'Err' field in the first argument,
%            if also the first argument is not a structure then will
%            set all the errors to be 1.
%            Default is empty.
%          * Arbitrary number of pairs of arguments: ...,keyword,value,...
%            where keyword are one of the followings:
%            'FracApp'  - The minimum fraction of apperances of a source
%                         in the images in order to be used as a standard
%                         star. Default is 1.0.
%            'MinErr'   - Use sources which error (median) is larger than
%                         this value. Default is 0.003 mag.
%            'MaxErr'   - Use sources which error (median) is smaller than
%                         this value. Default is 0.05 mag.
%            'FunErr'   - Function for selecting typical error.
%                         Default is @median.
%            'MaxStd    - Maximum StD of relative photometry magnitudes
%                         of a source in order to be included as
%                         standard star. Default is 0.1 mag.
%            'JD'       - Vector of JDs. Default is [].
%            'UseInfoJD'- Use JD from input structure. Default is true.
%            'FieldMag' - Name of instrumental magnitudes field in input
%                         structure. Default is 'MAG_AUTO'.
%            'FieldMagErr' - Name of instrumental magnitudes error field
%                         in input structure. Default is 'MAGERR_AUTO'.
%            'FieldAdd' - Cell array of additional fields to use in the
%                         solution. For example,
%                         {'XWIN_IMAGE','YWIN_IMAGE','AM'},
%                         will fit:
%                         InstMag_ij = ZP_i + <Mag>_j + alpha*XWIN_IMAGE + beta*YWIN_IMAGE + gamma*AM
%                         Default is {}.
%            'FlagSrc'  - Vector of flags indicating good sources to use
%                         as standard stars. Default is []. If empty,
%                         then will use all sources.
%            'SparseH'  - Use a sparse design matrix. Default is true.
%            'AlgoLSQ'  - LSQ algorithm {'\'|'lscov'|'ls_conjgrad'}
%                         Default is 'ls_conjgrad'. Note that this option
%                         do not calculate errors on best fit parameters.
%            'LSQparAdd'- Additional parameters to pass to ls_conjgrad.m.
%                         Default is {}.
%            'lscovAlgo'- lscov.m algorithm {'chol' | 'orth'}.
%                         Default is 'chol'.
%            'ls_conjgradAlgo' - ls_conjgrad.m algorithm. Default is 'pcg'.
%            'MaxIter'  - Maximum number of sigma clipping iterations.
%                         Default is 0.
%            'Verbose'  - Verbose. Default is true.
% Output : - Structure of best fit results.
% Tested : Matlab R2014a
%     By : Eran O. Ofek                    Jan 2015
%    URL : http://weizmann.ac.il/home/eofek/matlab/
% Example: Out=phot_relzp;  % run in simulation mode
% Reliable: 2
%--------------------------------------------------------------------------

FieldJD             = 'JD';
FieldInfo           = 'Info';

if (nargin==0),
    % simulation mode
    Nim     = 100;
    Nsrc    = 1000;
    ZP      = rand(Nim,1);
    MeanMag = 15+rand(1,Nsrc,1).*3;
    
    Mag = bsxfun(@plus,ZP,MeanMag);
    Err = 0.02;
    Mag = Mag + randn(size(Mag)).*Err;
    Err = ones(size(Mag)).*Err;
    
    %std(Out.Par(1:Nim)-ZP)
    %std(Out.Par(Nim+1:end)-MeanMag')
end

if (nargin==1),
    Err = [];
end


DefV.FracApp          = 1.0;
DefV.MinErr           = 0.003;
DefV.MaxErr           = 0.05;
DefV.FunErr           = @median;
DefV.MaxStd           = 0.1;
DefV.JD               = [];
DefV.UseInfoJD        = true;
DefV.FieldMag         = 'MAG_AUTO';
DefV.FieldMagErr      = 'MAGERR_AUTO';
DefV.FieldAdd         = {};   % {'XWIN_IMAGE','YWIN_IMAGE','AM'}
%DefV.FlagIm           = [];   % Flag of good images
DefV.FlagSrc          = [];   % Flag of good stars
DefV.SparseH          = true;
DefV.AlgoLSQ          = 'ls_conjgrad';   % {'\'|'lscov'|'ls_conjgrad'}
DefV.LSQparAdd        = {};
DefV.lscovAlgo        = 'chol';
DefV.ls_conjgradAlgo  = 'pcg';
DefV.MaxIter          = 0;
%DefV.ResidPar         = {'Method','StdP','Mean','median','Clip',[3 3]};
DefV.Verbose          = true;

InPar = set_varargin_keyval(DefV,'n','use',varargin{:});

Nfa   = numel(InPar.FieldAdd);

if (isstruct(Mag)),
    if (isempty(InPar.JD) && InPar.UseInfoJD),
        if (isfield(Mag,FieldInfo) && isfield(Mag,FieldJD)),
            InPar.JD   = Mag.(FieldInfo).(FieldJD);
        end
    end
    
    for Ifa=1:1:Nfa,
        Mat.(InPar.FiedlAdd{Ifa}) = Mag.(InPar.FiedlAdd{Ifa});
    end
        
    if (isempty(Err) && ~isempty(InPar.FieldMagErr)),
        % If Err is not provided use Err field in structure
        Err    = Mag.(InPar.FieldMagErr);
    end
    Mag    = Mag.(InPar.FieldMag);    
end


% number of images and number of sources
[Nim,Nsrc] = size(Mag);

if (isempty(InPar.JD)),
    InPar.JD = (1:1:Nim)';
end

if (isempty(Err)),
    Err = ones(size(Mag));
end

% if (isempty(InPar.FlagIm)),
%     InPar.FlagIm = true(Nim,1);
% end
if (isempty(InPar.FlagSrc)),
    InPar.FlagSrc = true(1,Nsrc);
end


FlagSrcInit = sum(~isnan(Mag))>=(Nim.*InPar.FracApp) & InPar.FunErr(Err,1)<InPar.MaxErr & InPar.FunErr(Err,1)>InPar.MinErr;
FlagSrc = InPar.FlagSrc & FlagSrcInit;
if (InPar.Verbose)
    fprintf('Number of reference stars: %d\n',sum(InPar.FlagSrc));
end


if (~isempty(InPar.FieldAdd)),
    error('FieldAdd option is not yet available');
end



% construct the design matrix for the equation
% mag_ij = zp_i + <mag>_j  (i-image, j-star)
Neq  = Nim.*Nsrc;
Npar = Nim+Nsrc;

if (InPar.SparseH),
    H = sparse([],[],[],Neq,Npar,2.*Neq);
else
    H = zeros(Neq,Npar);
end
VecMag  = zeros(Neq,1);
VecErr  = zeros(Neq,1);
VecFlag = false(Neq,1);

JmagBlock = (Nim+1:1:Nim+Nsrc);
for Iblock=1:1:Nim,
    % indices of current block lines
    Iline=(1:1:Nsrc).' + (Iblock-1).*Nsrc;
    % design matrix
    H(Iline,Iblock) = 1;      % ZP sub block
    H(Iline,JmagBlock) = diag(ones(Nsrc,1)); % mean mag (diagonal) block
    
    % Vector of observations
    VecMag(Iline)  = Mag(Iblock,:).';
    VecErr(Iline)  = Err(Iblock,:).';
    VecFlag(Iline) = FlagSrc;
end
FlagCol = true(1,Nim+Nsrc);

%FlagSrc = VecFlag;

Cont    = true;
Iiter   = 0;   % first iteration is 0
while (Cont)
%     FlagCol = sum(H(VecFlag,:)~=0)>0;
%     'FlagCol'
%     sum(FlagCol)
    
    switch lower(InPar.AlgoLSQ)
        case '\'
            Out.Par       = H(VecFlag,FlagCol)\VecMag(VecFlag);
            Out.ParErr    = nan(size(Out.Par));
            Out.AllResid  = VecMag - H(:,FlagCol)*Out.Par;
            Out.Resid     = Out.AllResid(VecFlag);
            Out.Chi2      = sum((Out.Resid./VecErr(VecFlag)).^2);
            Out.Npar      = Npar;
            Out.Neq       = numel(Out.Resid);   % Neq when use all
            Out.Dof       = Neq - Npar;
            Out.Cov       = [];
        case 'lscov'
           
            [Out.Par,Out.ParErr] = lscov(H(VecFlag,FlagCol),VecMag(VecFlag),VecErr(VecFlag).^-2,InPar.lscovAlgo);
            Out.AllResid         = VecMag - H(:,FlagCol)*Out.Par;
            Out.Resid            = Out.AllResid(VecFlag);
            Out.Chi2             = sum((Out.Resid./VecErr(VecFlag)).^2);
            Out.Npar             = Npar;
            Out.Neq              = numel(Out.Resid);
            Out.Dof              = Neq - Npar;
            Out.Cov              = [];

        case 'ls_conjgrad'
          
            Out = ls_conjgrad(H(VecFlag,FlagCol),VecMag(VecFlag),VecErr(VecFlag),InPar.ls_conjgradAlgo,InPar.LSQparAdd{:});
            %Out = ls_conjgrad(H,VecMag,1,Algo,InPar.LSQparAdd{:});
            Out.AllResid         = VecMag - H(:,FlagCol)*Out.Par;
            Out.Resid            = Out.AllResid(VecFlag);
            Out.Chi2             = sum((Out.Resid./VecErr(VecFlag)).^2);
            Out.Npar             = Npar;
            Out.Neq              = numel(Out.Resid);
            Out.Dof              = Neq - Npar;
            Out.Cov              = [];

        otherwise
            error('Unknown AlgoLSQ option');
    end

    Iiter = Iiter + 1;
    Out.ZP          = Out.Par(1:1:Nim);
    Out.Mag         = bsxfun(@minus,Mag,Out.ZP);
    FlagSrc         = nanstd(Out.Mag)<InPar.MaxStd & FlagSrcInit;
    VecFlag         = repmat(FlagSrc.',Nim,1);
    FlagCol         = [true(1,Nim), FlagSrc];
    
    Cont  = Iiter<=InPar.MaxIter;
end
Out.ZP          = Out.Par(1:1:Nim);
Out.ZPErr       = Out.ParErr(1:1:Nim);
Out.Mag         = bsxfun(@minus,Mag,Out.ZP);
Out.IndSrc      = find(FlagCol(Nim+1:end));





